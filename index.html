<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  
  <!-- ビューポートを端末幅に合わせ、縮尺統一 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

  <title>Galaxy Escape - モバイル向け重力迷路ゲーム</title>
  <style>
    /* --------------------------------------------------------------------------
       全体のスタイル定義
       - 画面いっぱいに広がるCanvasと各種UI要素（ボタン、スコア表示、ゲームオーバー表示など）
       - 全ブラウザ・端末で同様の縮尺・レイアウトになるように
       - 「▶ ゲームスタート」や「タップで再挑戦」などはユーザの要望に合わせ改行やnowrapを調整
    -------------------------------------------------------------------------- */

    :root {
      --primary-color: #4CAF50;
      --secondary-color: #2196F3;
      --danger-color: #F44336;
      --text-color: rgba(255,255,255,0.9);
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: radial-gradient(circle at center, #1a1a1a, #000);
      overflow: hidden;
      font-family: 'Segoe UI', system-ui, sans-serif;
    }

    /* ゲーム描画用キャンバス */
    #gameCanvas {
      display: block;
      width: 100vw;
      height: 100vh;
      background: radial-gradient(circle at 50% 100%, #2a2a2a, #1a1a1a);
    }

    /* 開始／リセットボタン（改行なし） */
    #startButton {
      white-space: nowrap;  /* 「▶ ゲームスタート」は改行しない */
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      padding: 15px 40px;
      font-size: 1.2em;
      cursor: pointer;
      z-index: 10;
      background: linear-gradient(145deg, var(--primary-color), #45a049);
      color: var(--text-color);
      border: none;
      border-radius: 30px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
      transition: all 0.3s ease;
      font-weight: 600;
      letter-spacing: 1px;
    }
    #startButton:hover {
      transform: translateX(-50%) scale(1.05);
      box-shadow: 0 6px 20px rgba(0,0,0,0.4);
    }

    /* スコア表示 */
    #scoreDisplay {
      position: fixed;
      top: 25px;
      left: 25px;
      color: var(--text-color);
      font-size: 1.8em;
      z-index: 10;
      background: rgba(0,0,0,0.6);
      padding: 12px 25px;
      border-radius: 15px;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      white-space: nowrap; /* SCORE: XX などは改行防止 */
    }

    /* ゲームオーバー表示（複数行） */
    #gameOverDisplay {
      /* white-space: nowrap; ← 削除：改行して良い */
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: var(--danger-color);
      font-size: 3.5em;
      text-align: center;
      z-index: 20;
      display: none;
      text-shadow: 0 4px 10px rgba(244,67,54,0.3);
      background: rgba(0,0,0,0.8);
      padding: 30px 50px;
      border-radius: 20px;
      border: 2px solid var(--danger-color);
    }

    /* プログレスバー（スコアの進捗を可視化） */
    #progressBar {
      position: fixed;
      top: 25px;
      right: 25px;
      width: 200px;
      height: 12px;
      background: rgba(255,255,255,0.1);
      border-radius: 6px;
      overflow: hidden;
      display: none;
    }
    #progressFill {
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
      transition: width 0.3s ease;
    }

    /* 難易度アップ通知（改行なし） */
    .difficulty-notice {
      white-space: nowrap;  /* 改行なし */
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.9);
      color: var(--text-color);
      padding: 15px 30px;
      border-radius: 10px;
      font-size: 1.4em;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      border: 1px solid var(--primary-color);
      box-shadow: 0 0 20px rgba(76,175,80,0.3);
    }

    /* ボーナス獲得時のポップアップ演出 */
    .bonus-popup {
      position: absolute;
      color: #4CAF50;
      font-weight: bold;
      font-size: 1.2em;
      animation: floatUp 1s ease-out forwards;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    @keyframes floatUp {
      0% { opacity: 1; transform: translateY(0); }
      100% { opacity: 0; transform: translateY(-50px); }
    }
  </style>
</head>
<body>
  <!-- 
      ----------------------------------------------------------------------------
      【ゲーム全体ロジック概要】
      1. ビューポート固定で、どのブラウザでも同じ縮尺になるように調整
      2. Canvas(#gameCanvas)でネオン風ボールと壁を描画
      3. 「▶ ゲームスタート」は改行なし(#startButton)
      4. ゲームオーバーは複数行(「GAME OVER」と「タップで再挑戦」は別行で)
      5. 難易度通知は改行なし(.difficulty-notice)
      6. サブステップ方式の衝突判定で加速度的すり抜けを防ぐ
      7. 一度衝突しても抜けられればボーナス加算
      ----------------------------------------------------------------------------
  -->

  <button id="startButton">▶ ゲームスタート</button>
  <canvas id="gameCanvas"></canvas>
  <div id="scoreDisplay">SCORE: 0</div>

  <!-- ゲームオーバー表示(複数行OK) -->
  <div id="gameOverDisplay">
    <div>GAME OVER</div>
    <div style="font-size: 0.3em; margin-top: 15px; color: rgba(255,255,255,0.8);">タップで再挑戦</div>
  </div>

  <!-- プログレスバー -->
  <div id="progressBar"><div id="progressFill"></div></div>

  <!-- 難易度アップ通知（改行なし） -->
  <div class="difficulty-notice" id="difficultyNotice">難易度が上がりました！</div>

  <script>
    /* 
      ========= グローバル変数・初期設定 =========
    */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const startButton = document.getElementById('startButton');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const gameOverDisplay = document.getElementById('gameOverDisplay');
    const progressBar = document.getElementById('progressBar');
    const progressFill = document.getElementById('progressFill');
    const difficultyNotice = document.getElementById('difficultyNotice');

    let animationId = null; // requestAnimationFrame管理

    // 画面サイズ調整
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ボール関連
    let charX, charY;
    const radius = 10;

    // センサー関連
    let currentBeta = 0, currentGamma = 0;
    let smoothBeta = 0, smoothGamma = 0;
    const smoothingFactor = 0.1;
    let baseBeta = 0, baseGamma = 0;

    // ゲーム状態
    let gameStarted = false;
    let gameOver = false;

    // スコア・難易度
    let score = 100;
    let nextMilestone = 1000;
    let baseWallSpeed = 2;
    let baseGapWidth = 100;
    let baseCollisionPenalty = 10;
    const pushForce = 5;

    // 壁関連
    let walls = [];
    const wallThickness = 20;
    let wallTimer = 0;
    const wallInterval = 150;

    // iOS向けセンサー許可(必要時)
    if (typeof DeviceMotionEvent.requestPermission === 'function') {
      document.body.addEventListener('click', async () => {
        try {
          const response = await DeviceMotionEvent.requestPermission();
          if (response === 'granted') {
            console.log('センサーアクセス許可');
          }
        } catch (e) {
          console.error(e);
        }
      }, { once: true });
    }

    // deviceorientation イベントでBeta/Gamma取得
    window.addEventListener('deviceorientation', (event) => {
      currentBeta = event.beta;
      currentGamma = event.gamma;
    }, true);

    // ========== 開始／リセット ボタン ==========
    startButton.addEventListener('click', () => {
      if (animationId !== null) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      resetGame();
      animationId = requestAnimationFrame(loop);
    });

    // ========== 初期化処理 ==========
    function resetGame() {
      score = 100;
      nextMilestone = 1000;
      baseWallSpeed = 2;
      baseGapWidth = 100;
      baseCollisionPenalty = 10;

      charX = canvas.width / 2;
      charY = canvas.height / 2;

      walls = [];
      wallTimer = 0;

      gameOver = false;
      gameOverDisplay.style.display = "none";

      baseBeta = currentBeta;
      baseGamma = currentGamma;
      smoothBeta = currentBeta;
      smoothGamma = currentGamma;

      gameStarted = true;
      updateScoreDisplay();
      updateProgressBar();
    }

    // ========== 衝突判定 ==========
    function isBallCollidingWithWall(wall) {
      return (
        (charY + radius > wall.y && charY - radius < wall.y + wall.thickness) &&
        (charX - radius < wall.gapX || charX + radius > wall.gapX + wall.gapWidth)
      );
    }

    // ========== 壁生成 ==========
    function createWall() {
      const margin = 50;
      const gapX = Math.random() * (canvas.width - baseGapWidth - 2*margin) + margin;
      return {
        y: -wallThickness,
        gapX: gapX,
        gapWidth: baseGapWidth,
        thickness: wallThickness,
        processed: false,
        collided: false
      };
    }

    // ========== 壁更新・衝突/ボーナス処理 ==========
    function updateWalls() {
      for (let wall of walls) {
        wall.y += baseWallSpeed;

        // 衝突
        if (!wall.processed && isBallCollidingWithWall(wall)) {
          if (!wall.collided) {
            score -= baseCollisionPenalty;
            wall.collided = true;
          }
          charY += pushForce;
        }

        // ボーナス判定: ボールを下に抜けた瞬間
        if (!wall.processed && wall.y > charY && !isBallCollidingWithWall(wall)) {
          let bonus = Math.round((canvas.height - charY) / 5);
          score += bonus;
          addScoreBonus(bonus, charX, charY);
          wall.processed = true;
        }
      }

      // 画面下に消えた壁を削除
      walls = walls.filter(w => w.y < canvas.height);

      // 定期的に壁生成
      wallTimer++;
      if (wallTimer > wallInterval) {
        walls.push(createWall());
        wallTimer = 0;
      }
    }

    // ========== 難易度アップ ==========
    function checkDifficultyUp() {
      if (score >= nextMilestone) {
        difficultyNotice.style.opacity = '1';
        setTimeout(() => {
          difficultyNotice.style.opacity = '0';
        }, 1500);

        baseWallSpeed += 1;
        baseGapWidth -= 10;
        if (baseGapWidth < 20) baseGapWidth = 20;
        baseCollisionPenalty += 5;
        nextMilestone += 1000;
      }
    }

    // ========== ボール移動(サブステップ) ==========
    function updateBall() {
      if (!gameStarted) return;

      smoothBeta = smoothBeta * (1 - smoothingFactor) + currentBeta * smoothingFactor;
      smoothGamma = smoothGamma * (1 - smoothingFactor) + currentGamma * smoothingFactor;

      let diffBeta = smoothBeta - baseBeta;
      let diffGamma = smoothGamma - baseGamma;

      const threshold = 1.0;
      if (Math.abs(diffBeta) < threshold) diffBeta = 0;
      if (Math.abs(diffGamma) < threshold) diffGamma = 0;

      const sensitivityX = 0.3;
      const sensitivityY = 0.15;
      let deltaX = diffGamma * sensitivityX;
      let deltaY = diffBeta * sensitivityY;

      const maxDeltaX = 8, maxDeltaY = 5;
      deltaX = Math.max(Math.min(deltaX, maxDeltaX), -maxDeltaX);
      deltaY = Math.max(Math.min(deltaY, maxDeltaY), -maxDeltaY);

      const steps = 4;
      const stepX = deltaX / steps;
      const stepY = deltaY / steps;

      for (let i = 0; i < steps; i++) {
        charX += stepX;
        charY += stepY;

        // 画面端クランプ
        if (charX < radius) charX = radius;
        if (charX > canvas.width - radius) charX = canvas.width - radius;
        if (charY < radius) charY = radius;
        if (charY > canvas.height - radius) charY = canvas.height - radius;

        // 壁衝突
        for (let wall of walls) {
          if (!wall.processed && isBallCollidingWithWall(wall)) {
            if (!wall.collided) {
              score -= baseCollisionPenalty;
              wall.collided = true;
            }
            charY += pushForce;
            if (charY > canvas.height - radius) {
              charY = canvas.height - radius;
            }
          }
        }
      }
    }

    // ========== スコア表示更新 ==========
    function updateScoreDisplay() {
      scoreDisplay.textContent = `SCORE: ${score}`;
    }

    // ========== ボーナス演出 ==========
    function addScoreBonus(bonus, x, y) {
      const popup = document.createElement('div');
      popup.className = 'bonus-popup';
      popup.textContent = `+${bonus}`;
      popup.style.left = `${x}px`;
      popup.style.top = `${y}px`;
      document.body.appendChild(popup);

      setTimeout(() => popup.remove(), 1000);
    }

    // ========== ゲームオーバー判定 ==========
    function checkGameOver() {
      if (score < 0 || charY + radius >= canvas.height) {
        gameOver = true;
        gameOverDisplay.style.display = "block";
        progressBar.style.display = 'none';

        // 赤影演出
        ctx.shadowColor = 'rgba(244,67,54,0.5)';
        ctx.shadowBlur = 50;
        ctx.fillStyle = 'rgba(244,67,54,0.2)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.shadowBlur = 0;
      }
    }

    // ========== 背景エフェクト ==========
    function drawBackgroundEffects() {
      if (Math.random() < 0.05) {
        ctx.fillStyle = `rgba(255,255,255,${Math.random()*0.3})`;
        ctx.fillRect(
          Math.random()*canvas.width,
          Math.random()*canvas.height,
          1.5, 1.5
        );
      }
    }

    // ========== プログレスバー更新 ==========
    function updateProgressBar() {
      const progress = (score % 1000) / 1000 * 100;
      progressFill.style.width = `${progress}%`;
      progressBar.style.display = gameStarted ? 'block' : 'none';
    }

    // ========== メイン描画処理 ==========
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackgroundEffects();

      // ネオングラデのボール
      const gradient = ctx.createRadialGradient(
        charX, charY, 0,
        charX, charY, radius*2
      );
      gradient.addColorStop(0, 'rgba(76,175,80,1)');
      gradient.addColorStop(1, 'rgba(76,175,80,0.3)');

      ctx.beginPath();
      ctx.arc(charX, charY, radius, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.shadowColor = '#4CAF50';
      ctx.shadowBlur = 15;
      ctx.fill();
      ctx.shadowBlur = 0;

      // 壁描画(ネオンレッド)
      walls.forEach(wall => {
        const wallGradient = ctx.createLinearGradient(0, wall.y, 0, wall.y + wall.thickness);
        wallGradient.addColorStop(0, '#F44336');
        wallGradient.addColorStop(1, '#D32F2F');

        ctx.fillStyle = wallGradient;
        ctx.shadowColor = '#F44336';
        ctx.shadowBlur = 10;
        // 左壁
        ctx.fillRect(0, wall.y, wall.gapX, wall.thickness);
        // 右壁
        ctx.fillRect(wall.gapX + wall.gapWidth, wall.y,
          canvas.width - (wall.gapX + wall.gapWidth), wall.thickness);
        ctx.shadowBlur = 0;
      });

      updateProgressBar();
    }

    // ========== メインループ ==========
    function loop() {
      if (!gameOver) {
        updateBall();
        updateWalls();
        checkDifficultyUp();
        checkGameOver();
        updateScoreDisplay();
        draw();
        animationId = requestAnimationFrame(loop);
      } else {
        animationId = null;
      }
    }

    // ========== ゲームオーバー表示タップで再スタート ==========
    gameOverDisplay.addEventListener('click', () => {
      startButton.click();
    });
  </script>
</body>
</html>
